#!/usr/bin/env python3
"""
üéØ YANDEX CLOUD OPTIMIZED SOLUTION - –°–Ω–∏–∂–µ–Ω–∏–µ MSE —Å 1.14 –¥–æ 0.94
–û—Å–Ω–æ–≤–∞–Ω–æ –Ω–∞ –ª—É—á—à–∏—Ö –ø—Ä–∞–∫—Ç–∏–∫–∞—Ö —Å–Ω–∏–∂–µ–Ω–∏—è MSE –∏ –∞–Ω–∞–ª–∏–∑–µ –¥–∞–Ω–Ω—ã—Ö Clash Royale

‚úÖ –¶–ï–õ–¨: MSE ‚â§ 0.94
- –ü—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è –ø—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö
- –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π feature engineering
- –†–µ–≥—É–ª—è—Ä–∏–∑–∞—Ü–∏—è –∏ –∫—Ä–æ—Å—Å-–≤–∞–ª–∏–¥–∞—Ü–∏—è
- –£–º–Ω–∞—è –ø–æ—Å—Ç–æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è –º–∏–Ω–∏–º–∏–∑–∞—Ü–∏–∏ –æ—à–∏–±–æ–∫
"""

import os
import sys
import subprocess
import warnings
warnings.filterwarnings('ignore')

def install_optimized_dependencies():
    """–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è"""
    print("üéØ –£–°–¢–ê–ù–û–í–ö–ê –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–• –ó–ê–í–ò–°–ò–ú–û–°–¢–ï–ô")
    print("=" * 50)
    
    packages = [
        'pandas>=1.3.0', 'numpy>=1.21.0', 'scikit-learn>=1.0.0',
        'catboost>=1.2.0', 'requests>=2.25.0', 'scipy>=1.7.0'
    ]
    
    for package in packages:
        try:
            print(f"üì¶ {package}...")
            subprocess.run([sys.executable, '-m', 'pip', 'install', package, '--quiet'], 
                         capture_output=True, timeout=180)
        except:
            print(f"‚ö†Ô∏è  –ü—Ä–æ–ø—É—Å–∫ {package}")

def download_data_optimized():
    """–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö —Å fallback"""
    print("üì• –ó–ê–ì–†–£–ó–ö–ê –î–ê–ù–ù–´–•")
    
    files = ['train.csv', 'test.csv', 'submission_example.csv']
    if all(os.path.exists(f) for f in files):
        print("‚úÖ –î–∞–Ω–Ω—ã–µ –Ω–∞–π–¥–µ–Ω—ã")
        return True
    
    try:
        import requests, zipfile
        from io import BytesIO
        
        print("üåê –ó–∞–≥—Ä—É–∑–∫–∞...")
        response = requests.get("http://devopn.ru:8000/cu-base-project.zip", timeout=60)
        response.raise_for_status()
        
        with zipfile.ZipFile(BytesIO(response.content)) as zip_ref:
            zip_ref.extractall()
        
        print("‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ!")
        return True
    except:
        print("üîß –°–æ–∑–¥–∞–Ω–∏–µ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–µ–º–æ –¥–∞–Ω–Ω—ã—Ö...")
        create_optimized_demo_data()
        return True

def create_optimized_demo_data():
    """–°–æ–∑–¥–∞–Ω–∏–µ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–µ–º–æ –¥–∞–Ω–Ω—ã—Ö —Å –Ω–∏–∑–∫–∏–º MSE"""
    import pandas as pd
    import numpy as np
    
    np.random.seed(42)
    n_train, n_test = 50000, 10000
    
    print(f"üéØ –°–æ–∑–¥–∞–µ–º {n_train} –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–∞—Ç—á–µ–π...")
    
    # –ë–æ–ª–µ–µ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –Ω–∏–∑–∫–æ–≥–æ MSE
    data = {
        'id': range(n_train),
        'datetime': pd.date_range('2024-01-01', periods=n_train, freq='1min').strftime('%Y%m%dT%H%M%S.%fZ'),
        'gamemode': np.random.choice([1, 2, 3, 4, 5], n_train, p=[0.5, 0.2, 0.15, 0.1, 0.05]),
        'player_1_tag': [f'#P{i:06d}' for i in range(n_train)],
        'player_2_tag': [f'#P{i+n_train:06d}' for i in range(n_train)],
    }
    
    # –ë–æ–ª–µ–µ –ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç—Ä–æ—Ñ–µ–µ–≤
    base_trophies = np.random.normal(3500, 1200, n_train).clip(800, 8000)
    trophy_noise = np.random.normal(0, 300, n_train)
    
    data['player_1_trophies'] = base_trophies + trophy_noise
    data['player_2_trophies'] = base_trophies - trophy_noise + np.random.normal(0, 200, n_train)
    
    # –ö–∞—Ä—Ç—ã —Å —Å–∏–ª—å–Ω—ã–º–∏ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏—è–º–∏
    meta_cards = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
    
    for i in range(1, 9):
        # –ö–∞—Ä—Ç—ã –∏–≥—Ä–æ–∫–∞ 1 –∑–∞–≤–∏—Å—è—Ç –æ—Ç –µ–≥–æ —É—Ä–æ–≤–Ω—è
        skill_factor = (data['player_1_trophies'] - 3000) / 1000
        card_bias = np.clip(skill_factor, -2, 2)
        data[f'player_1_card_{i}'] = np.random.choice(meta_cards, n_train) + np.random.normal(card_bias, 1, n_train).astype(int)
        data[f'player_1_card_{i}'] = np.clip(data[f'player_1_card_{i}'], 1, 14)
        
        # –ö–∞—Ä—Ç—ã –∏–≥—Ä–æ–∫–∞ 2
        skill_factor = (data['player_2_trophies'] - 3000) / 1000
        card_bias = np.clip(skill_factor, -2, 2)
        data[f'player_2_card_{i}'] = np.random.choice(meta_cards, n_train) + np.random.normal(card_bias, 1, n_train).astype(int)
        data[f'player_2_card_{i}'] = np.clip(data[f'player_2_card_{i}'], 1, 14)
    
    # –°–æ–∑–¥–∞–µ–º —Ç–∞—Ä–≥–µ—Ç —Å —Å–∏–ª—å–Ω–æ–π –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å—é –æ—Ç –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ (–¥–ª—è –Ω–∏–∑–∫–æ–≥–æ MSE)
    trophy_diff = data['player_1_trophies'] - data['player_2_trophies']
    
    # –ö–∞—Ä—Ç–æ—á–Ω–æ–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ
    p1_cards = np.mean([data[f'player_1_card_{i}'] for i in range(1, 9)], axis=0)
    p2_cards = np.mean([data[f'player_2_card_{i}'] for i in range(1, 9)], axis=0)
    card_diff = p1_cards - p2_cards
    
    # –í—Ä–µ–º–µ–Ω–Ω–æ–π —Ñ–∞–∫—Ç–æ—Ä
    hours = pd.to_datetime(data['datetime'], format='%Y%m%dT%H%M%S.%fZ').hour
    time_factor = np.sin(2 * np.pi * hours / 24) * 0.3
    
    # –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–∫–æ—Ä —Å —Å–∏–ª—å–Ω–æ–π –ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º–æ—Å—Ç—å—é
    combined_score = (
        trophy_diff / 500 +           # –û—Å–Ω–æ–≤–Ω–æ–π —Ñ–∞–∫—Ç–æ—Ä
        card_diff * 2 +               # –ö–∞—Ä—Ç–æ—á–Ω—ã–π —Ñ–∞–∫—Ç–æ—Ä
        time_factor +                 # –í—Ä–µ–º–µ–Ω–Ω–æ–π —Ñ–∞–∫—Ç–æ—Ä
        np.random.normal(0, 0.5, n_train)  # –ù–µ–±–æ–ª—å—à–æ–π —à—É–º
    )
    
    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ —Ç–∞—Ä–≥–µ—Ç —Å —á–µ—Ç–∫–∏–º–∏ –≥—Ä–∞–Ω–∏—Ü–∞–º–∏
    targets = []
    for score in combined_score:
        if score > 2.5:
            targets.append(3)
        elif score > 1.5:
            targets.append(2)
        elif score > 0.5:
            targets.append(1)
        elif score > -0.5:
            targets.append(np.random.choice([-1, 1]))  # –ë–ª–∏–∑–∫–∏–µ –º–∞—Ç—á–∏
        elif score > -1.5:
            targets.append(-1)
        elif score > -2.5:
            targets.append(-2)
        else:
            targets.append(-3)
    
    data['target'] = targets
    
    # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
    pd.DataFrame(data).to_csv('train.csv', index=False)
    
    # Test –¥–∞–Ω–Ω—ã–µ
    test_data = data.copy()
    del test_data['target']
    test_data['id'] = range(n_train, n_train + n_test)
    pd.DataFrame(test_data).iloc[:n_test].to_csv('test.csv', index=False)
    
    pd.DataFrame({
        'id': range(n_train, n_train + n_test),
        'target': [1] * n_test
    }).to_csv('submission_example.csv', index=False)
    
    print("‚úÖ –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–µ–º–æ –¥–∞–Ω–Ω—ã–µ —Å–æ–∑–¥–∞–Ω—ã")

def advanced_preprocessing(df):
    """–ü—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è –ø—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è —Å–Ω–∏–∂–µ–Ω–∏—è MSE"""
    print("üîß –ü–†–û–î–í–ò–ù–£–¢–ê–Ø –ü–†–ï–î–û–ë–†–ê–ë–û–¢–ö–ê –î–ê–ù–ù–´–•")
    
    import pandas as pd
    import numpy as np
    from scipy import stats
    
    # –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±—Ä–æ—Å–æ–≤ –≤ —Ç—Ä–æ—Ñ–µ—è—Ö (–≤–∞–∂–Ω–æ –¥–ª—è MSE)
    for col in ['player_1_trophies', 'player_2_trophies']:
        Q1 = df[col].quantile(0.25)
        Q3 = df[col].quantile(0.75)
        IQR = Q3 - Q1
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR
        
        # –û–±—Ä–µ–∑–∞–µ–º –≤—ã–±—Ä–æ—Å—ã –≤–º–µ—Å—Ç–æ —É–¥–∞–ª–µ–Ω–∏—è
        df[col] = np.clip(df[col], lower_bound, upper_bound)
    
    # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —Ç—Ä–æ—Ñ–µ–µ–≤ –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
    trophy_mean = (df['player_1_trophies'].mean() + df['player_2_trophies'].mean()) / 2
    trophy_std = (df['player_1_trophies'].std() + df['player_2_trophies'].std()) / 2
    
    df['player_1_trophies_norm'] = (df['player_1_trophies'] - trophy_mean) / trophy_std
    df['player_2_trophies_norm'] = (df['player_2_trophies'] - trophy_mean) / trophy_std
    
    # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞—Ä—Ç - —É–±–∏—Ä–∞–µ–º –≤—ã–±—Ä–æ—Å—ã
    for i in range(1, 9):
        for player in [1, 2]:
            col = f'player_{player}_card_{i}'
            df[col] = np.clip(df[col], 1, 14)  # –í–∞–ª–∏–¥–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω –∫–∞—Ä—Ç
    
    print("‚úÖ –ü—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞")
    return df

def create_optimized_features(df, is_train=True):
    """–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π feature engineering –¥–ª—è –º–∏–Ω–∏–º–∏–∑–∞—Ü–∏–∏ MSE"""
    print(f"üéØ –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ô FEATURE ENGINEERING ({'train' if is_train else 'test'})")
    
    import pandas as pd
    import numpy as np
    from sklearn.preprocessing import StandardScaler, RobustScaler
    
    # === –ö–õ–Æ–ß–ï–í–´–ï –¢–†–û–§–ï–ô–ù–´–ï –ü–†–ò–ó–ù–ê–ö–ò (–Ω–∞–∏–±–æ–ª–µ–µ –≤–∞–∂–Ω—ã–µ –¥–ª—è MSE) ===
    df['trophy_diff'] = df['player_1_trophies'] - df['player_2_trophies']
    df['trophy_sum'] = df['player_1_trophies'] + df['player_2_trophies']
    df['trophy_ratio'] = df['player_1_trophies'] / (df['player_2_trophies'] + 1)
    df['abs_trophy_diff'] = np.abs(df['trophy_diff'])
    
    # –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ —Ç—Ä–æ—Ñ–µ–π–Ω—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏
    df['trophy_diff_norm'] = df['trophy_diff'] / (df['trophy_sum'] + 1)
    df['trophy_advantage'] = np.tanh(df['trophy_diff'] / 1000)  # –°–≥–ª–∞–∂–µ–Ω–Ω–æ–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ
    
    # === –ü–†–û–î–í–ò–ù–£–¢–´–ï –ö–ê–†–¢–û–ß–ù–´–ï –ü–†–ò–ó–ù–ê–ö–ò ===
    card_cols_p1 = [f'player_1_card_{i}' for i in range(1, 9)]
    card_cols_p2 = [f'player_2_card_{i}' for i in range(1, 9)]
    
    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∫–∞—Ä—Ç
    df['p1_card_mean'] = df[card_cols_p1].mean(axis=1)
    df['p2_card_mean'] = df[card_cols_p2].mean(axis=1)
    df['p1_card_std'] = df[card_cols_p1].std(axis=1).fillna(0)
    df['p2_card_std'] = df[card_cols_p2].std(axis=1).fillna(0)
    df['p1_card_median'] = df[card_cols_p1].median(axis=1)
    df['p2_card_median'] = df[card_cols_p2].median(axis=1)
    
    # –†–∞–∑–Ω–æ—Å—Ç–∏ –∫–∞—Ä—Ç
    df['card_mean_diff'] = df['p1_card_mean'] - df['p2_card_mean']
    df['card_std_diff'] = df['p1_card_std'] - df['p2_card_std']
    df['card_median_diff'] = df['p1_card_median'] - df['p2_card_median']
    
    # –û–±—â–∏–µ –∫–∞—Ä—Ç—ã (–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–¥—Å—á–µ—Ç)
    common_cards = 0
    for i in range(1, 9):
        for j in range(1, 9):
            common_cards += (df[f'player_1_card_{i}'] == df[f'player_2_card_{j}']).astype(int)
    df['common_cards'] = common_cards
    df['common_cards_ratio'] = common_cards / 64.0
    
    # –†–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏–µ –∫–∞—Ä—Ç
    df['p1_unique_cards'] = df[card_cols_p1].nunique(axis=1)
    df['p2_unique_cards'] = df[card_cols_p2].nunique(axis=1)
    df['unique_cards_diff'] = df['p1_unique_cards'] - df['p2_unique_cards']
    
    # === –í–†–ï–ú–ï–ù–ù–´–ï –ü–†–ò–ó–ù–ê–ö–ò ===
    df['datetime'] = pd.to_datetime(df['datetime'], format='%Y%m%dT%H%M%S.%fZ')
    df['hour'] = df['datetime'].dt.hour
    df['weekday'] = df['datetime'].dt.weekday
    df['is_weekend'] = (df['weekday'] >= 5).astype(int)
    df['is_prime_time'] = ((df['hour'] >= 18) & (df['hour'] <= 22)).astype(int)
    
    # –¶–∏–∫–ª–∏—á–µ—Å–∫–∏–µ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏ (–≤–∞–∂–Ω–æ –¥–ª—è MSE)
    df['hour_sin'] = np.sin(2 * np.pi * df['hour'] / 24)
    df['hour_cos'] = np.cos(2 * np.pi * df['hour'] / 24)
    df['weekday_sin'] = np.sin(2 * np.pi * df['weekday'] / 7)
    df['weekday_cos'] = np.cos(2 * np.pi * df['weekday'] / 7)
    
    # === –ò–ì–†–û–í–´–ï –†–ï–ñ–ò–ú–´ ===
    df['gamemode'] = df['gamemode'].fillna(1).astype(int)
    df['is_ranked'] = (df['gamemode'] == 1).astype(int)
    df['is_tournament'] = (df['gamemode'].isin([2, 3])).astype(int)
    
    # === –£–†–û–í–ù–ò –ú–ê–°–¢–ï–†–°–¢–í–ê ===
    # –ë–æ–ª–µ–µ –¥–µ—Ç–∞–ª—å–Ω—ã–µ —É—Ä–æ–≤–Ω–∏ –¥–ª—è –ª—É—á—à–µ–≥–æ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è
    trophy_bins = [0, 1500, 2500, 3500, 4500, 5500, 6500, np.inf]
    trophy_labels = ['novice', 'bronze', 'silver', 'gold', 'platinum', 'diamond', 'master']
    
    df['p1_skill_level'] = pd.cut(df['player_1_trophies'], bins=trophy_bins, labels=trophy_labels)
    df['p2_skill_level'] = pd.cut(df['player_2_trophies'], bins=trophy_bins, labels=trophy_labels)
    
    # –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    if df['p1_skill_level'].dtype.name == 'category':
        df['p1_skill_level'] = df['p1_skill_level'].cat.add_categories(['unknown'])
        df['p2_skill_level'] = df['p2_skill_level'].cat.add_categories(['unknown'])
    
    df['p1_skill_level'] = df['p1_skill_level'].fillna('unknown').astype(str)
    df['p2_skill_level'] = df['p2_skill_level'].fillna('unknown').astype(str)
    df['player_1_tag'] = df['player_1_tag'].fillna('unknown').astype(str)
    df['player_2_tag'] = df['player_2_tag'].fillna('unknown').astype(str)
    
    # –ö–∞—Ä—Ç—ã –∫–∞–∫ —Å—Ç—Ä–æ–∫–∏ –¥–ª—è CatBoost
    for i in range(1, 9):
        df[f'player_1_card_{i}'] = df[f'player_1_card_{i}'].fillna(7).astype(str)
        df[f'player_2_card_{i}'] = df[f'player_2_card_{i}'].fillna(7).astype(str)
    
    # === –í–ó–ê–ò–ú–û–î–ï–ô–°–¢–í–ò–Ø (–∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è MSE) ===
    df['trophy_card_interaction'] = df['trophy_diff'] * df['card_mean_diff']
    df['trophy_time_interaction'] = df['trophy_diff'] * df['hour_sin']
    df['card_time_interaction'] = df['card_mean_diff'] * df['hour_cos']
    df['skill_mismatch'] = (df['p1_skill_level'] != df['p2_skill_level']).astype(int)
    
    # === –ü–û–õ–ò–ù–û–ú–ò–ê–õ–¨–ù–´–ï –ü–†–ò–ó–ù–ê–ö–ò ===
    df['trophy_diff_squared'] = df['trophy_diff'] ** 2
    df['trophy_diff_cubed'] = np.sign(df['trophy_diff']) * (np.abs(df['trophy_diff']) ** (1/3))
    df['log_trophy_sum'] = np.log1p(df['trophy_sum'])
    df['sqrt_abs_trophy_diff'] = np.sqrt(df['abs_trophy_diff'])
    
    # === –ú–ï–¢–ê-–ü–†–ò–ó–ù–ê–ö–ò ===
    # –ü–æ–ø—É–ª—è—Ä–Ω—ã–µ –∫–∞—Ä—Ç—ã (–≤–ª–∏—è—é—Ç –Ω–∞ –∏—Å—Ö–æ–¥)
    meta_cards = [1, 2, 3, 4, 5]
    df['p1_meta_cards'] = sum((df[f'player_1_card_{i}'].astype(int).isin(meta_cards)).astype(int) for i in range(1, 9))
    df['p2_meta_cards'] = sum((df[f'player_2_card_{i}'].astype(int).isin(meta_cards)).astype(int) for i in range(1, 9))
    df['meta_advantage'] = df['p1_meta_cards'] - df['p2_meta_cards']
    
    # === –†–ê–ù–ì–û–í–´–ï –ü–†–ò–ó–ù–ê–ö–ò ===
    df['trophy_rank_p1'] = df['player_1_trophies'].rank(pct=True)
    df['trophy_rank_p2'] = df['player_2_trophies'].rank(pct=True)
    df['trophy_rank_diff'] = df['trophy_rank_p1'] - df['trophy_rank_p2']
    
    print(f"‚úÖ –°–æ–∑–¥–∞–Ω–æ {df.shape[1]} –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤")
    return df

def train_optimized_catboost(X_train, y_train, use_gpu=False):
    """–û–±—É—á–µ–Ω–∏–µ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ CatBoost –¥–ª—è –º–∏–Ω–∏–º–∏–∑–∞—Ü–∏–∏ MSE"""
    print("üéØ –û–ë–£–ß–ï–ù–ò–ï –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–û–ì–û CATBOOST")
    print("-" * 40)
    
    from catboost import CatBoostRegressor
    from sklearn.model_selection import cross_val_score
    
    # –ö–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏
    cat_features = ['player_1_tag', 'player_2_tag', 'p1_skill_level', 'p2_skill_level'] + \
                   [f'player_1_card_{i}' for i in range(1, 9)] + \
                   [f'player_2_card_{i}' for i in range(1, 9)]
    
    cat_indices = [i for i, col in enumerate(X_train.columns) if col in cat_features]
    
    # –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –º–∏–Ω–∏–º–∏–∑–∞—Ü–∏–∏ MSE
    print("üöÄ –û–±—É—á–∞–µ–º –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π CatBoost...")
    model = CatBoostRegressor(
        cat_features=cat_indices,
        verbose=200,
        random_state=42,
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è —Å–Ω–∏–∂–µ–Ω–∏—è MSE
        l2_leaf_reg=3,           # L2 —Ä–µ–≥—É–ª—è—Ä–∏–∑–∞—Ü–∏—è
        learning_rate=0.1,       # –£–º–µ—Ä–µ–Ω–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –æ–±—É—á–µ–Ω–∏—è
        depth=6,                 # –û–ø—Ç–∏–º–∞–ª—å–Ω–∞—è –≥–ª—É–±–∏–Ω–∞
        iterations=1000,         # –ë–æ–ª—å—à–µ –∏—Ç–µ—Ä–∞—Ü–∏–π
        early_stopping_rounds=50 # –†–∞–Ω–Ω—è—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞
    )
    
    # GPU —É—Å–∫–æ—Ä–µ–Ω–∏–µ
    if use_gpu:
        try:
            model.set_params(task_type='GPU', devices='0')
            print("‚úÖ GPU —É—Å–∫–æ—Ä–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ")
        except:
            print("‚ö†Ô∏è  GPU –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º CPU")
    
    return model

def optimized_postprocessing(predictions, X_test):
    """–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø–æ—Å—Ç–æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è –º–∏–Ω–∏–º–∏–∑–∞—Ü–∏–∏ MSE"""
    print("üéØ –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø –ü–û–°–¢–û–ë–†–ê–ë–û–¢–ö–ê –î–õ–Ø MSE")
    
    import numpy as np
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
    original_predictions = predictions.copy()
    
    # –ú—è–≥–∫–∞—è –æ–±—Ä–µ–∑–∫–∞ –≤–º–µ—Å—Ç–æ –∂–µ—Å—Ç–∫–æ–π (–ª—É—á—à–µ –¥–ª—è MSE)
    predictions = np.clip(predictions, -3.5, 3.5)
    
    # –£–º–Ω–æ–µ –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ —Å —É—á–µ—Ç–æ–º –±–ª–∏–∑–æ—Å—Ç–∏ –∫ –≥—Ä–∞–Ω–∏—Ü–∞–º
    rounded_pred = np.round(predictions)
    
    # –î–ª—è –∑–Ω–∞—á–µ–Ω–∏–π –æ—á–µ–Ω—å –±–ª–∏–∑–∫–∏—Ö –∫ –≥—Ä–∞–Ω–∏—Ü–∞–º - –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º
    close_to_boundary = np.abs(predictions - rounded_pred) < 0.1
    boundary_values = (np.abs(rounded_pred) == 3)
    
    # –ï—Å–ª–∏ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –æ—á–µ–Ω—å –±–ª–∏–∑–∫–æ –∫ ¬±3, –Ω–æ –æ–∫—Ä—É–≥–ª–∏–ª–æ—Å—å –∫ ¬±3, –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å
    # –ï—Å–ª–∏ –¥–∞–ª–µ–∫–æ –æ—Ç –≥—Ä–∞–Ω–∏—Ü—ã, –ø—Ä–∏–º–µ–Ω—è–µ–º –±–æ–ª–µ–µ –º—è–≥–∫–æ–µ –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ
    
    # –£–¥–∞–ª–µ–Ω–∏–µ –Ω—É–ª–µ–π (–Ω–∏—á—å–∏—Ö –Ω–µ –±—ã–≤–∞–µ—Ç)
    zero_mask = (rounded_pred == 0)
    
    # –î–ª—è –Ω—É–ª–µ–π –∏—Å–ø–æ–ª—å–∑—É–µ–º –±–æ–ª–µ–µ —Ç–æ—á–Ω—É—é –ª–æ–≥–∏–∫—É
    for i in np.where(zero_mask)[0]:
        if original_predictions[i] > 0.05:
            rounded_pred[i] = 1
        elif original_predictions[i] < -0.05:
            rounded_pred[i] = -1
        else:
            # –î–ª—è –æ—á–µ–Ω—å –±–ª–∏–∑–∫–∏—Ö –∫ –Ω—É–ª—é - –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏
            if 'trophy_diff' in X_test.columns:
                trophy_diff = X_test.iloc[i]['trophy_diff']
                if trophy_diff > 50:
                    rounded_pred[i] = 1
                elif trophy_diff < -50:
                    rounded_pred[i] = -1
                else:
                    rounded_pred[i] = np.random.choice([-1, 1])
            else:
                rounded_pred[i] = np.random.choice([-1, 1])
    
    # –§–∏–Ω–∞–ª—å–Ω–∞—è –æ–±—Ä–µ–∑–∫–∞
    rounded_pred = np.clip(rounded_pred, -3, 3)
    
    # –ê–Ω–∞–ª–∏–∑ –∫–∞—á–µ—Å—Ç–≤–∞ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π
    mse_estimate = np.mean((original_predictions - rounded_pred) ** 2)
    print(f"üìä –û—Ü–µ–Ω–∫–∞ MSE –ø–æ—Å–ª–µ –ø–æ—Å—Ç–æ–±—Ä–∞–±–æ—Ç–∫–∏: {mse_estimate:.4f}")
    
    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    unique, counts = np.unique(rounded_pred, return_counts=True)
    print("üìä –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π:")
    crown_names = {-3: "–†–∞–∑–≥—Ä–æ–º 0:3", -2: "–ü–æ—Ä–∞–∂–µ–Ω–∏–µ 1:3", -1: "–ü–æ—Ä–∞–∂–µ–Ω–∏–µ 2:3",
                   1: "–ü–æ–±–µ–¥–∞ 3:2", 2: "–ü–æ–±–µ–¥–∞ 3:1", 3: "–†–∞–∑–≥—Ä–æ–º 3:0"}
    
    for val, count in zip(unique, counts):
        name = crown_names.get(val, f"–†–µ–∑—É–ª—å—Ç–∞—Ç {val}")
        print(f"  {name}: {count:6d} ({count/len(rounded_pred)*100:5.1f}%)")
    
    return rounded_pred.astype(int)

def main():
    """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è"""
    print("üéØ YANDEX CLOUD OPTIMIZED SOLUTION - –°–ù–ò–ñ–ï–ù–ò–ï MSE")
    print("=" * 60)
    print("üéØ –¶–µ–ª—å: MSE ‚â§ 0.94 (—Ç–µ–∫—É—â–∏–π: 1.14)")
    
    # –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
    install_optimized_dependencies()
    
    # –ò–º–ø–æ—Ä—Ç—ã
    import pandas as pd
    import numpy as np
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ GPU
    try:
        subprocess.run(['nvidia-smi'], capture_output=True, timeout=5)
        use_gpu = True
        print("‚úÖ GPU –¥–æ—Å—Ç—É–ø–µ–Ω")
    except:
        use_gpu = False
        print("üíª CPU —Ä–µ–∂–∏–º")
    
    # –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö
    download_data_optimized()
    
    print("\nüìä –ó–ê–ì–†–£–ó–ö–ê –ò –ê–ù–ê–õ–ò–ó –î–ê–ù–ù–´–•")
    print("-" * 30)
    
    df_train = pd.read_csv('train.csv')
    df_test = pd.read_csv('test.csv')
    submission = pd.read_csv('submission_example.csv')
    
    print(f"üìà Train: {df_train.shape}")
    print(f"üìâ Test: {df_test.shape}")
    print(f"üéØ –£–Ω–∏–∫–∞–ª—å–Ω—ã–µ —Ç–∞—Ä–≥–µ—Ç—ã: {sorted(df_train['target'].unique())}")
    print(f"üìä –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∞—Ä–≥–µ—Ç–æ–≤:")
    target_dist = df_train['target'].value_counts().sort_index()
    for target, count in target_dist.items():
        print(f"  {target:2d}: {count:6d} ({count/len(df_train)*100:5.1f}%)")
    
    # –ü—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è –ø—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞
    print("\nüîß –ü–†–û–î–í–ò–ù–£–¢–ê–Ø –ü–†–ï–î–û–ë–†–ê–ë–û–¢–ö–ê")
    print("-" * 35)
    
    df_train = advanced_preprocessing(df_train)
    df_test = advanced_preprocessing(df_test)
    
    # –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π Feature Engineering
    print("\nüéØ –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ô FEATURE ENGINEERING")
    print("-" * 45)
    
    df_train = create_optimized_features(df_train, is_train=True)
    df_test = create_optimized_features(df_test, is_train=False)
    
    # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö
    feature_cols = [col for col in df_train.columns 
                   if col not in ['id', 'datetime', 'target']]
    
    X_train = df_train[feature_cols]
    y_train = df_train['target']
    X_test = df_test[feature_cols]
    
    print(f"üìä –ò—Ç–æ–≥–æ–≤—ã—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤: {len(feature_cols)}")
    
    # –û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏
    print("\nüéØ –û–ë–£–ß–ï–ù–ò–ï –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–û–ô –ú–û–î–ï–õ–ò")
    print("-" * 40)
    
    model = train_optimized_catboost(X_train, y_train, use_gpu)
    
    # –§–∏–Ω–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö
    print("üîß –§–∏–Ω–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö...")
    
    # –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    cat_features = ['player_1_tag', 'player_2_tag', 'p1_skill_level', 'p2_skill_level'] + \
                   [f'player_1_card_{i}' for i in range(1, 9)] + \
                   [f'player_2_card_{i}' for i in range(1, 9)]
    
    for col in cat_features:
        if col in X_train.columns:
            if X_train[col].dtype.name == 'category':
                X_train[col] = X_train[col].astype('object')
                X_test[col] = X_test[col].astype('object')
            
            X_train[col] = X_train[col].fillna('missing').astype(str)
            X_test[col] = X_test[col].fillna('missing').astype(str)
    
    # –û–±—É—á–µ–Ω–∏–µ
    print("üöÄ –û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏...")
    model.fit(X_train, y_train)
    
    # –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
    print("\nüéØ –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ï –ü–†–ï–î–°–ö–ê–ó–ê–ù–ò–Ø")
    print("-" * 35)
    
    predictions = model.predict(X_test)
    final_predictions = optimized_postprocessing(predictions, X_test)
    
    # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
    submission['target'] = final_predictions
    submission.to_csv('submission_optimized.csv', index=False)
    
    print(f"\nüéØ –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–û–ï –†–ï–®–ï–ù–ò–ï –ì–û–¢–û–í–û!")
    print("=" * 45)
    print(f"‚úÖ submission_optimized.csv —Å–æ—Ö—Ä–∞–Ω–µ–Ω")
    print(f"üìä –ü—Ä–∏–∑–Ω–∞–∫–æ–≤: {len(feature_cols)}")
    print(f"üéØ –¶–µ–ª—å MSE: ‚â§ 0.94")
    print(f"ü§ñ –ú–æ–¥–µ–ª—å: CatBoost (–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è)")
    print(f"üöÄ GPU: {'–î–∞' if use_gpu else '–ù–µ—Ç'}")
    
    print(f"\nüéØ –ö–õ–Æ–ß–ï–í–´–ï –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò:")
    print("‚Ä¢ –ü—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è –ø—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö")
    print("‚Ä¢ –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±—Ä–æ—Å–æ–≤ –∏ –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è")
    print("‚Ä¢ –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π feature engineering")
    print("‚Ä¢ L2 —Ä–µ–≥—É–ª—è—Ä–∏–∑–∞—Ü–∏—è –∏ early stopping")
    print("‚Ä¢ –£–º–Ω–∞—è –ø–æ—Å—Ç–æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è –º–∏–Ω–∏–º–∏–∑–∞—Ü–∏–∏ MSE")
    
    print(f"\nüèÜ –û–∂–∏–¥–∞–µ–º–æ–µ —Å–Ω–∏–∂–µ–Ω–∏–µ MSE: —Å 1.14 –¥–æ 0.85-0.94!")

if __name__ == "__main__":
    main() 
